package org.javai.springai.actions.sql;

import java.util.List;

/**
 * Payload for SQL query working context in multi-turn conversations.
 * 
 * <p>Stores the "model SQL" â€” the SQL as the LLM sees and generates it,
 * using synonyms/tokens rather than resolved canonical names. This is
 * the form that should be shown back to the LLM for query refinement.</p>
 * 
 * <h2>Model SQL vs Resolved SQL</h2>
 * <ul>
 *   <li><b>Model SQL</b>: {@code SELECT order_value FROM orders} (synonyms)</li>
 *   <li><b>Resolved SQL</b>: {@code SELECT order_value FROM fct_orders} (canonical)</li>
 * </ul>
 * 
 * <p>The LLM should see the model SQL to maintain consistency with the
 * catalog synonyms shown in the prompt.</p>
 * 
 * @param modelSql the SQL as the LLM generated it (using synonyms/tokens)
 * @param tables list of referenced table names (canonical, for metadata)
 * @param selectedColumns list of selected column names
 * @param whereClause the WHERE clause if present (for summary)
 */
public record SqlQueryPayload(
		String modelSql,
		List<String> tables,
		List<String> selectedColumns,
		String whereClause
) {
	/** Context type identifier for registration */
	public static final String CONTEXT_TYPE = "sql.query";

	/**
	 * Creates a payload from the model SQL string only.
	 * 
	 * <p>Metadata (tables, columns, where) will be empty.</p>
	 * 
	 * @param modelSql the model SQL string
	 * @return a new payload
	 */
	public static SqlQueryPayload fromModelSql(String modelSql) {
		return new SqlQueryPayload(modelSql, List.of(), List.of(), null);
	}

	/**
	 * Creates a payload from a Query, extracting metadata.
	 * 
	 * <p><b>Note:</b> This uses the resolved SQL from the Query. For proper
	 * multi-turn support, you should capture the model SQL before resolution
	 * and use {@link #fromModelSql(String)} or the full constructor.</p>
	 * 
	 * @param query the resolved Query
	 * @return a new payload with metadata extracted
	 */
	public static SqlQueryPayload fromQuery(Query query) {
		return new SqlQueryPayload(
				query.modelSql(),
				query.referencedTables(),
				query.selectedColumns(),
				query.whereClause().orElse(null)
		);
	}

	/**
	 * Creates a payload with the model SQL and metadata from a resolved Query.
	 * 
	 * <p>This is the preferred factory method when you have access to both
	 * the original model SQL and the resolved Query.</p>
	 * 
	 * @param modelSql the original SQL as generated by the LLM
	 * @param query the resolved Query for metadata extraction
	 * @return a new payload
	 */
	public static SqlQueryPayload fromModelSqlAndQuery(String modelSql, Query query) {
		return new SqlQueryPayload(
				modelSql,
				query.referencedTables(),
				query.selectedColumns(),
				query.whereClause().orElse(null)
		);
	}
}

